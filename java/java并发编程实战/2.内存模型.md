---
typora-copy-images-to: image
typora-root-url: ./
---

导致**可见性**的原因是**缓存**

导致**有序性**的原因是**编译优化**

合理的解决方案就是**按需禁用**缓存及编译优化

### Java内存模型

Java内存模型规范了JVM如何提供**按需禁用缓存和编译优化的方法**

这些方法包括 volatile、synchronized 和final 三个关键字，以及六项 Happens-Before 规则

### **volatile**

**意义就是禁用 CPU 缓存。**

声明一个 volatile 变量volatile int x = 0，

它表达的是：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。

在实际使用的时候却会带来困惑：

```java

class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里 x 会是多少呢？
    }
  }
}

```

假设线程 A 执行 writer() 方法，按照volatile 语义，会把变量 “v=true”写入内存；假设线程 B 执行 reader() 方法，同样按照 volatile 语义，线程 B 会从内存中读取变量 v，如果线程 B 看到 “v == true” 时，那么线程 B 看到的变量 x 是多少呢？

这个要看 Java 的版本，如果在低于 1.5 版本上运行，x 可能是 42，也有可能是 0（原因是变量x可能被CPU缓存）；如果在 1.5 以上的版本上运行，x 就是等于 42。（因为Java内存模型在1.5版本对volatile语义进行了增强（happens-Before规则）

### happens-Before规则

happens-Before原则的意识就是：**前面一个操作的结果对后续操作是可见的**。

happens-Before约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守happens-Before原则。

#### 六项规则+两项规则

1. ##### 程序的顺序性规则

   程序前面对某个变量的**修改**一定对后续操作是**可见的**。（单线程思维）

2. ##### volatile变量规则

   对一个volatile变量的**写**操作，happens-Before于后续对这个变量的**读**操作

3. ##### 传递性

   这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么**A** Happens-Before **C**。

   ![传递性规则](/image/传递性规则.png)

4. 管程中锁的规则

   一个锁的**解锁** Happens-Before 于后续对这个锁的的**加锁。**

   

   管程是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。

   

5. 线程 start() 规则

   主线程 A 启动子线程 B 后，**子线程 B** 能够看到主线程在启动子线程 B **前的操作**。

   ```java
   Thread B = new Thread(()->{
     // 主线程调用 B.start() 之前
     // 所有对共享变量的修改，此处皆可见
     // 此例中，var==77
   });
   // 此处对共享变量 var 修改
   var = 77;
   // 主线程启动子线程
   B.start();
   
   ```

6. 线程 join() 规则

   主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的的操作。当然所谓的“看到”，指的是对共享变量的操作。

7.   线程中断规则

   对线程interrupt()方法（线程中断方法）的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。

8. 对象终结规则

   一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。

9. 

#### final

final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。

构造函数“逸出”

```java
// 以下代码来源于【参考 1】
final int x;
// 错误的构造函数
public FinalFieldExample() { 
  x = 3;
  y = 4;
  // 此处就是讲 this 逸出，
  global.obj = this;
}

```

在构造函数里面将 this 赋值给了全局变量global.obj，这就是“逸出”，线程通过global.obj 读取 x 是有可能读到 0 的。因此我们使用final 修饰变量时，一定要避免“逸出”。

**思考**

有一个共享变量 abc，在一个线程里设置了 abc 的值abc=3，你思考一下，有哪些办法可以让其他线程能够看到abc==3？

1.声明共享变量abc，并使用volatile关键字修饰abc
2.声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值。
3.A线程启动后，使用A.JOIN()方法来完成运行，后续线程再启动，则一定可以看到abc==3



**附加：**

  线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。

所以，个人对于Java内存模型总结起来就是：

1. 为什么定义Java内存模型？现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为**处理器的乱序执行**。在Java中，不同的线程可能访问同一个共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为**编译器的重排序**。除了处理器的乱序执行、编译器的重排序，还有**内存系统的重排序**。因此Java语言规范引入了**Java内存模型**，通过定义多项规则对编译器和处理器进行限制，主要是针对**可见性和有序性。**

2. 三个基本原则：原子性、可见性、有序性。

3.  Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。其中：

   第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，**在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见**。

   第二是volatile字段，volatile字段可以看成是一种**不保证原子性的同步但保证可见性的特性**，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。

   第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，**其他线程能够看到已经初始化的final实例字段**，这是安全的。

4.  Happens-Before的7个规则：
   (1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是**控制流顺序**而不是程序代码顺序，因为要考虑分支、循环等结构。
   (2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而"后面"是指时间上的先后顺序。
   (3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。
   (4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
   (5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
   (6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
   (7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始

5. Happens-Before的1个特性：传递性。

6.  Java内存模型底层怎么实现的？主要是通过**内存屏障(memory barrier)禁止重排序的**，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。 







推荐地址：https://docs.oracle.com/javase/specs/































