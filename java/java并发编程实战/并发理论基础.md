---

typora-copy-images-to: image
typora-root-url: ./
---

#### 可见性、原子性、有序性

**可见性：**一个线程对共享变量的修改，另外一个线程能够立即看到



##### 并发编程Bug的源头

###### 一、缓存导致的可见性问题

1、在单核时代，所有的线程都是在一颗cpu上执行的，cpu缓存和内存数据一致性很容易解决。因为所有的线程都是操作同一个cpu缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。



![a07e8182819e2b260ce85b2167d446da](/image/CPU 缓存与内存的关系图.png)

2、在多核时代，每颗cpu都有自己的缓存，这时cpu缓存与内存的数据一致性问题就没有那么容易解决了，当多个线程在不同的cpu上执行时，这些线程操作的是不同的cpu缓存。

![多核cpu可见性问题](/image/多核 CPU 的缓存与内存关系图.png)

我们来看一下下面代码的执行结果

```java
![变量 count 在 CPU 缓存和内存的分布图](/C:/Users/Axing/Desktop/变量 count 在 CPU 缓存和内存的分布图.pngpublic class Test {
  private long count = 0;
  private void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      count += 1;
    }
  }
  public static long calc() {
    final Test test = new Test();
    // 创建两个线程，执行 add() 操作
    Thread th1 = new Thread(()->{
      test.add10K();
    });
    Thread th2 = new Thread(()->{
      test.add10K();
    });
    // 启动两个线程
    th1.start();
    th2.start();
    // 等待两个线程执行结束
    th1.join();
    th2.join();
    return count;
  }
}

```

实际上 calc() 的执行结果是个 10000 到 20000的随机数

我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。

![变量 count 在 CPU 缓存和内存的分布图](/image/变量 count 在 CPU 缓存和内存的分布图.png)

###### 二、线程切换带来的原子性问题

**时间片：**操作系统允许某个进程执行一小段时间，过了这段时间以后,就会重新选择一个进程来执行（我们称为“任务切换”）执行的这一小段时间称为时间片

![线程切换示意图](/image/线程切换示意图.png)

**在一个时间片内**，如果一个进程进行IO操作，例如读取一个文件，这个时候该进程可以把自己标记为“休眠状态”，并让出cpu的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得cpu的使用权。

这里的进程在等待IO时之所以会释放cpu的使用权，是为了让cpu在这段时间里可以做别的事情，这样一来cpu使用率就上来了。如果这个时候有另外一个进程也读文件，读文件操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队任务，就会立即启动下一个读操作，这样IO的使用率也上来了

吧 



















