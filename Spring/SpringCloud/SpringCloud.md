---

typora-copy-images-to: image
typora-root-url: ./
---

### 面试题

------

#### 1、什么是微服务？

<https://martinfowler.com/articles/microservices.html>



#### 2、微服务之间是如何独立通讯的？

#### 3、SpringCloud和Dubbo有哪些区别？

#### 4、SpringBoot和SpringCloud，请你谈谈对他们的理解？

#### 5、什么是服务熔断？什么是服务降级？

#### 6、微服务的优缺点分别是什么？说说你在项目目中碰到的坑

#### 7、你所知道的微服务技术栈有哪些？

#### 8、eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？

### 微服务概述：

------

##### 1、什么是微服务

微服务的核心就是将传统的一站式应用，根据业务才分成一个一个服务，彻底的去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情。从技术的角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。

##### 2、微服务与微服务架构

**微服务：**强调的是服务的大小，他关注的是某一个点，是具体解决某个问题/提供落地对应服务的一个服务应用。

强调的是一个个的个体，每个个体完成一个具体的任务或者功能。（一个个微服务工程/module）

**微服务架构：**微服务架构是一种架构模式，它提倡将单一应用程序划分为一组微小的服务，服务之间互相协调，互相配合，为用户提供最终价值，	每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通讯机制互相协作（通常是基于HTTP协议的RESTful API），每个服务围绕着具体的业务进行构建，并且能够被独立的部署到生产环境，类生产环境等。另外，应当尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。

##### 3、微服务的优缺点

**优点：**

每个服务足够内聚、足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求

开发简单、开发效率提高，一个服务可能就是专一的只干一件事

服务能够被小团队单独开发，这个小团队是2到5个人的开发人员组成。

微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的

微服务能使用不同的语言开发

易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins，Hudson，banboo

微服务易于被一个开发人员理解，修改，维护，这样小团队能够更关注自己的工作成果，无须通过合作才能体现价值

微服务允许你利用、融合最新的技术

微服务只是业务逻辑的代码，不会和HTML，CSS或其他界面组件混合

每个微服务都有自己的存能力，可以有自己的数据库，也可以有统一的数据库

**缺点：**

开发人员要处理分布式系统的复杂性

多服务运维难度，随着服务的增加，运维的压力也在增大

系统部署依赖

服务间通讯成本

数据一致性

系统集成测试

性能监控

##### 4、微服务技术栈有哪些？

微服务技术栈：多种技术的集合体

|                微服务条目                |                           落地技术                           |
| :--------------------------------------: | :----------------------------------------------------------: |
|                 服务开发                 |                SpringBoot、Spring、SpringMVC                 |
|              服务配置与管理              |            Netflix公司的Archaius、阿里的Diamond等            |
|              服务注册与发现              |                 Eureka、Consul、Zookeeper等                  |
|                 服务调用                 |                       Rest、RPC、gRPC                        |
|                服务熔断器                |                       Hystrix、Envoy等                       |
|                 负载均衡                 |                       Ribbon、Nginx等                        |
| 服务接口调用（客户端调用服务的简化工具） |                           Feign等                            |
|                 消息队列                 |                 Kafka、RabbitMQ、ActiveMQ等                  |
|             服务配置中心管理             |                  SpringCloudConfig、Chef等                   |
|           服务路由（API网关）            |                            Zuul等                            |
|                 服务监控                 |             Zabbix、Nagios、Metrics、Spectator等             |
|                全链路追踪                |                   Zipkin、Brave、Dapper等                    |
|                 服务部署                 |               Docker、OpenStack、Kubernetes等                |
|             数据流操作开发包             | SpringCloud Stream(封装与Redis、RabbitMQ、Kafka等发送接收消息) |
|               时间消息总线               |                       Spring Cloud Bus                       |

##### 5、为什么选择SpringCloud作为微服务架构？

**技术选型：**

整体解决方案和框架成熟度

社区热度

可维护性

学习曲线

**当前各大IT公司用的微服务架构有哪些？**

阿里  Dubbo/HSF

京东  JSF

新浪微博  Motan

当当网 DubboX





### SpringCloud入门概述

------

**1、什么是SpringCloud**

SpringCloud，基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡、熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还要一些选型中立的开源组件

SpringCloud利用SpringBoot的开发便利性巧妙地简化了分布式系统基础设施的开发，SpringCloud为开发人员提供了，快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等，它们都可以用SpringBoot的开发风格做到一键启动和部署。

SpringBoot并没有重复造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包

SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，微服务全家桶

**2、SpringBoot和SpringCloud是什么关系**

SpringBoot专注于快速方便的开发单个个体微服务。

SpringCloud是关注全局的微服务协调整理治理框架，他将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供、配置管理，服务发现，断路器、路由、微代理、事件总线，全局锁、决策竞选、分布式会话等等集成服务

SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系

SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局服务治理框架

**3、Dubbo和SpringCould的区别**

Dubbo的定位始终是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案

在面临微服务基础框架选型时Dubbo和SpringCloud生态是只能二选一

**4、SpringCloud学习**

<https://springcloud.cc/spring-cloud-netflix.html>

<https://springcloud.cc/spring-cloud-dalston.html>

<https://springcloud.cc/>

<http://springcloud.cn/>





### Rest微服务构建案例工程模块

------





### Eureka服务注册与发现

------

Netflix在设计Eureka时遵守的就是AP原则，主要用来实现服务注册与发现

Eurake采用了c-s的设计架构，Eurake Server作为微服务注册功能的服务器，他是服务注册中心，而系统的其他服务，使用Eureka的客户端连接到Eurake Server并维持心跳连接，这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。SpringCloud的一些其他模块（比如Zuul）就可以通过Eureka Server来发现系统中的其他微服务，并执行相关逻辑。

Eureka包含两个组件：Eureka Server和Eurake Client

Eureka Server提供服务注册服务

各个节点启动后，会在Eureka中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点信息，服务节点信息可在界面中直观的看到

EurekaClient是一个java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的，使用轮询（round-robin）负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳（默认周期30秒）。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务及节点移除（默认90秒）

**Eureka自我保护机制：**某时刻某一服务不可了，Eureka不会立即清除，依旧会对该服务的信息进行保存

在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数从新恢复到阈值以上时，该Eureka节点就会自动退出自我保护模式。它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能的服务实例

综上所述，自我保护模式是一种应对网络异常的安全保护措施，它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。

在SpringCloud中，可以使用eureka.server.enable-self-preservation = false 禁用自我保护模式

##### Eureka集群

修改本机host文件，域名映射

C:\Windows\System32\drivers\etc      host

127.0.0.1  eureka7001.com
127.0.0.1  eureka7002.com
127.0.0.1  eureka7003.com



#### 关于ACID和CAP——AP原则

**ACID：**Atomicity原子性，Consistency一致性，Isolation独立性，Durability持久性

#### CAP：Consistency强一致性，Availability可用性，Partition tolerance分区容错性

CAP的3进2

CAP理论就是说在分布式存储系统中，最多只能实现上面两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，**所以分区容错性是我们必须要实现的，**我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。

CA - 传统Oracle数据库

AP - 大多数网站架构的选择

CP - Redis、MongoDB

注意：分布式架构的时候必须做出取舍

CAP理论中：最多只能同时较好的满足两个

CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，因此，根据CAP原理将NOSQL数据库分成了满足CA原则、满足AP原则和满足AP原则三大类：

CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。

CP - 满足一致性，分区容错性的系统，通常性能不是特别高。

AP - 满足可用性，分区容错性的系统，通常可能对一致性要求低一些

![1558438571662](/image/1558438571662.png)

京东618我们只能选择AP，可用性要比一致性重要



##### Eureka和zookeeper比较

作为服务注册中心。Eureka比Zookeeper好在哪里？

著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性是在分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。

因此

Zookeeper保证的是CP，Eureka保证的是AP

**Zookeeper保证的是CP**

向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但是不能接受服务直接down掉不可用，也就是说，服务注册功能对可用性的要求高于一致性，但Zk会出现这样的一种情况，当master节点因为网络故障与其他节点失去联系，剩余节点会从新进行leader选举。问题在于，选举leader的时间太长，30~120s，且选举期间整个Zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。

**Eureka保证的是AP**

Eureka看明白了这一点，因此在设计时就优先保证可用性，Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余节点依然可以提供注册查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）。除此之外，Eureka还有一种自我保护机制，如果15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现网络故障，此时会出现以下情况：

1、Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务

2、Eureka仍然能够接受服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用）

3、当网络稳定时，当前实例新的注册信息会被同步到其他节点中

因此，Rureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper那样使整个注册服务瘫痪。





### Ribbon负载均衡

------

Spring Cloud Ribbon 是基于Netflix Ribbon实现的一套客户端   负载均衡的工具。

简单地说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单地说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器，我们也很容易使用Ribbon实现自定义负载均衡算法

LB，即负载均衡（Load Balance），在微服务或分布式集群中经常用的一种应用。

负载均衡简单地说就是将用户的请求平摊的分配到多个服务上吗，从而到达系统的HA（高可用）

常见的负载均衡软件有Nginx，LVS，硬件F5等

相应的中间件，例如：dubbo和SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义。

集中式LB

即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方

进程内LB

将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。

##### Ribbon核心组件IRule

根据特定算法中从服务列表中选取一个要访问的服务：

RoundRobinRule：轮询

RandomRule：随机

AvailabilityFilteringRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的链接数量超过阈值的服务，然后对剩余的列表按照轮询策略进行访问

WeightedResponseTimeRule：根据平均响应时间计算服务的权重，响应时间越快，服务权重越大，被选中的概率越高。刚启动时如果信息统计不足，则是用RoundRobinRule策略，等统计信息足够，会切换到WeightedResponseTimeRule

RetryRule：先按照RoundRobinRule的策略获取服务，如果服务获取服务失败则在指定时间内会进行重试，获取可用服务

BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务

ZoneAvoidanceRule：默认规则，复合判断server所在区域的性能和server的可用性选择服务器

##### 自定义负载均衡：

这个自定义的配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说，我们达不到特殊化定制的目的了。



### feign负载均衡

------

<https://cloud.spring.io/spring-cloud-static/Dalston.SR5/single/spring-cloud.html#spring-cloud-feign>

feign能干什么

Feign旨在使编写Java Http客户端变得更容易

前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模板化调用方法，但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖的服务调用，所以Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可），即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量。





Feign通过接口的方法调用Rest服务（之前是Ribbon+RestTemplate）

该请求发送给Eureka服务器，通过Reign直接找到服务接口，由于在进行服务调用的时候融入了Ribbon技术，所以也支持负载均衡





### Hystrix

------

**分布式系统面临的问题**

复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。

**服务雪崩**

对个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”，如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统奔溃，所谓"雪崩效应“

对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的多有资源都在几秒钟内饱和，比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不要导致整个应用程序或系统瘫痪。

**Hystrix**是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的的弹性。

“断路器”本身就是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack）,而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间，不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

**服务熔断**

 熔断机制是对雪崩效应的一种微服务链路保护机制。

当扇出链路的某个服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息，当检测到该节点微服务调用响应正常后恢复调用链路。在springCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状态，当失败的调用到一定的阈值，缺省时间是5秒内20次调用失败就会启动熔断机制。

```java
//一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法
@HystrixCommand(fallbackMethod = "processHystrix_Get")
```



